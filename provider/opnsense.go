package provider

import (
	"crypto/tls"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net"
	"net/http"
	"strings"
	"time"

	"go.uber.org/zap"
)

// DNSService interface for different DNS backends
type DNSService interface {
	CreateRecord(domain, ip string) error
	DeleteRecord(domain string) error
	UpdateRecord(domain, ip string) error
	FindRecord(domain string) (*DNSRecord, error)
}

// DNSRecord represents a DNS record
type DNSRecord struct {
	Domain      string
	IP          string
	RecordType  string
	UUID        string
	Enabled     bool
	Description string
}

// OPNsenseProvider implements DNSService for OPNsense
type OPNsenseProvider struct {
	hostname   string
	apiKey     string
	apiSecret  string
	dnsService string
	client     *http.Client
	logger     *zap.Logger
	debug      bool
}

type opnsenseOverride struct {
	UUID        string `json:"uuid"`
	Enabled     string `json:"enabled"`
	Hostname    string `json:"hostname"`
	Domain      string `json:"domain"`
	RR          string `json:"rr"`
	MXPrio      string `json:"mxprio"`
	MX          string `json:"mx"`
	Server      string `json:"server"`
	Description string `json:"description"`
}

// dnsmasqHost represents a dnsmasq host entry
type dnsmasqHost struct {
	UUID        string `json:"uuid"`
	Host        string `json:"host"`
	Domain      string `json:"domain"`
	IP          string `json:"ip"`
	Description string `json:"descr"`
}

// NewOPNsenseProvider creates a new OPNsense provider
func NewOPNsenseProvider(hostname, apiKey, apiSecret, dnsService string, insecure bool, logger *zap.Logger, debug bool) (*OPNsenseProvider, error) {
	if hostname == "" || apiKey == "" || apiSecret == "" {
		return nil, errors.New("opnsense provider requires hostname, api_key, and api_secret")
	}

	// Default to unbound if dns_service not specified
	if dnsService == "" {
		dnsService = "unbound"
	}

	// Validate dns_service
	if dnsService != "unbound" && dnsService != "dnsmasq" {
		return nil, fmt.Errorf("unsupported dns_service: %s (must be 'unbound' or 'dnsmasq')", dnsService)
	}

	tr := &http.Transport{}
	if insecure {
		tr.TLSClientConfig = &tls.Config{
			InsecureSkipVerify: true,
		}
		if debug {
			logger.Debug("OPNsense provider configured with insecure SSL", zap.String("hostname", hostname))
		}
	}

	client := &http.Client{
		Timeout:   15 * time.Second,
		Transport: tr,
	}

	if debug {
		logger.Debug("OPNsense provider created",
			zap.String("hostname", hostname),
			zap.String("dns_service", dnsService),
			zap.Bool("insecure", insecure))
	}

	return &OPNsenseProvider{
		hostname:   hostname,
		apiKey:     apiKey,
		apiSecret:  apiSecret,
		dnsService: dnsService,
		client:     client,
		logger:     logger,
		debug:      debug,
	}, nil
}

func (p *OPNsenseProvider) CreateRecord(domain, ip string) error {
	if !strings.Contains(domain, ".") {
		return fmt.Errorf("domain must contain a dot: %s", domain)
	}

	if p.debug {
		p.logger.Debug("creating DNS record",
			zap.String("domain", domain),
			zap.String("ip", ip),
			zap.String("provider_type", p.dnsService))
	}

	if p.dnsService == "dnsmasq" {
		return p.createDnsmasqRecord(domain, ip)
	}

	// Default to unbound
	return p.createUnboundRecord(domain, ip)
}

func (p *OPNsenseProvider) createUnboundRecord(domain, ip string) error {
	recordType := "A"
	if parsedIP := net.ParseIP(ip); parsedIP != nil && parsedIP.To4() == nil {
		recordType = "AAAA"
	}

	host := domain[:strings.IndexByte(domain, '.')]
	zone := domain[strings.IndexByte(domain, '.')+1:]

	if p.debug {
		p.logger.Debug("creating unbound record",
			zap.String("host", host),
			zap.String("zone", zone),
			zap.String("record_type", recordType),
			zap.String("ip", ip))
	}

	payload := map[string]any{
		"host": map[string]any{
			"enabled":     "1",
			"hostname":    host,
			"domain":      zone,
			"rr":          recordType,
			"mxprio":      "",
			"mx":          "",
			"server":      ip,
			"description": "Generated by Caddy Local DNS",
		},
	}

	resp, err := p.apiCall("unbound/settings/add_host_override", payload)
	if err != nil {
		return err
	}

	var res struct {
		Result string `json:"result"`
	}
	if err := json.Unmarshal(resp, &res); err != nil {
		return err
	}
	if res.Result != "saved" {
		return fmt.Errorf("add_override failed: %s", string(resp))
	}

	if p.debug {
		p.logger.Debug("unbound record created successfully", zap.String("domain", domain))
	}

	// Reload config
	return p.reconfigure()
}

func (p *OPNsenseProvider) createDnsmasqRecord(domain, ip string) error {
	host := domain[:strings.IndexByte(domain, '.')]
	zone := domain[strings.IndexByte(domain, '.')+1:]

	if p.debug {
		p.logger.Debug("creating dnsmasq record",
			zap.String("host", host),
			zap.String("zone", zone),
			zap.String("ip", ip))
	}

	payload := map[string]any{
		"host": map[string]any{
			"host":   host,
			"domain": zone,
			"ip":     ip,
			"descr":  "Generated by Caddy Local DNS",
		},
	}

	resp, err := p.apiCall("dnsmasq/settings/add_host", payload)
	if err != nil {
		return err
	}

	var res struct {
		Result string `json:"result"`
	}
	if err := json.Unmarshal(resp, &res); err != nil {
		return err
	}
	if res.Result != "saved" {
		return fmt.Errorf("add_host failed: %s", string(resp))
	}

	if p.debug {
		p.logger.Debug("dnsmasq record created successfully", zap.String("domain", domain))
	}

	// Reload config
	return p.reconfigure()
}

func (p *OPNsenseProvider) UpdateRecord(domain, ip string) error {
	if p.debug {
		p.logger.Debug("updating DNS record", zap.String("domain", domain), zap.String("ip", ip))
	}

	// Find existing record
	existing, err := p.FindRecord(domain)
	if err != nil {
		return err
	}
	if existing == nil {
		p.logger.Info("record not found during update, creating new one", zap.String("domain", domain))
		return p.CreateRecord(domain, ip)
	}

	if p.debug {
		p.logger.Debug("deleting existing record before update",
			zap.String("domain", domain),
			zap.String("uuid", existing.UUID))
	}

	// Delete old record
	if err := p.DeleteRecord(domain); err != nil {
		return err
	}

	// Create new record
	return p.CreateRecord(domain, ip)
}

func (p *OPNsenseProvider) DeleteRecord(domain string) error {
	if p.debug {
		p.logger.Debug("deleting DNS record", zap.String("domain", domain))
	}

	existing, err := p.FindRecord(domain)
	if err != nil {
		return err
	}
	if existing == nil {
		if p.debug {
			p.logger.Debug("record not found, nothing to delete", zap.String("domain", domain))
		}
		return nil // Already deleted
	}

	if p.debug {
		p.logger.Debug("found record to delete",
			zap.String("domain", domain),
			zap.String("uuid", existing.UUID))
	}

	var endpoint string
	if p.dnsService == "dnsmasq" {
		endpoint = "dnsmasq/settings/del_domain/" + existing.UUID
	} else {
		endpoint = "unbound/settings/del_host_override/" + existing.UUID
	}

	resp, err := p.apiCall(endpoint, nil)
	if err != nil {
		return err
	}

	var res struct {
		Result string `json:"result"`
	}
	if err := json.Unmarshal(resp, &res); err != nil {
		return err
	}
	if res.Result != "deleted" {
		return fmt.Errorf("delete_record failed: %s", string(resp))
	}

	if p.debug {
		p.logger.Debug("record deleted successfully", zap.String("domain", domain))
	}

	return p.reconfigure()
}

func (p *OPNsenseProvider) FindRecord(domain string) (*DNSRecord, error) {
	if !strings.Contains(domain, ".") {
		return nil, fmt.Errorf("domain must contain a dot: %s", domain)
	}

	if p.debug {
		p.logger.Debug("searching for DNS record",
			zap.String("domain", domain),
			zap.String("provider_type", p.dnsService))
	}

	if p.dnsService == "dnsmasq" {
		return p.findDnsmasqRecord(domain)
	}

	// Default to unbound
	return p.findUnboundRecord(domain)
}

func (p *OPNsenseProvider) findUnboundRecord(domain string) (*DNSRecord, error) {
	host := domain[:strings.IndexByte(domain, '.')]
	zone := domain[strings.IndexByte(domain, '.')+1:]

	if p.debug {
		p.logger.Debug("searching unbound records",
			zap.String("host", host),
			zap.String("zone", zone))
	}

	resp, err := p.apiCall("unbound/settings/search_host_override", nil)
	if err != nil {
		return nil, err
	}

	var data struct {
		Rows []opnsenseOverride `json:"rows"`
	}
	if err := json.Unmarshal(resp, &data); err != nil {
		return nil, err
	}

	if p.debug {
		p.logger.Debug("found unbound records", zap.Int("count", len(data.Rows)))
	}

	for _, row := range data.Rows {
		if row.Hostname == host && row.Domain == zone {
			// Extract just the record type (e.g., "A" from "A (IPv4 Address)")
			recordType := strings.SplitN(strings.TrimSpace(row.RR), " ", 2)[0]

			if p.debug {
				p.logger.Debug("found matching unbound record",
					zap.String("domain", domain),
					zap.String("uuid", row.UUID),
					zap.String("ip", row.Server),
					zap.String("enabled", row.Enabled),
					zap.String("raw_rr", row.RR),
					zap.String("parsed_record_type", recordType))
			}
			return &DNSRecord{
				Domain:      domain,
				IP:          row.Server,
				RecordType:  recordType,
				UUID:        row.UUID,
				Enabled:     row.Enabled == "1",
				Description: row.Description,
			}, nil
		}
	}

	if p.debug {
		p.logger.Debug("no matching unbound record found", zap.String("domain", domain))
	}
	return nil, nil
}

func (p *OPNsenseProvider) findDnsmasqRecord(domain string) (*DNSRecord, error) {
	host := domain[:strings.IndexByte(domain, '.')]
	zone := domain[strings.IndexByte(domain, '.')+1:]

	if p.debug {
		p.logger.Debug("searching dnsmasq records",
			zap.String("host", host),
			zap.String("zone", zone))
	}

	resp, err := p.apiCall("dnsmasq/settings/search_host", nil)
	if err != nil {
		return nil, err
	}

	var data struct {
		Rows []dnsmasqHost `json:"rows"`
	}
	if err := json.Unmarshal(resp, &data); err != nil {
		return nil, err
	}

	if p.debug {
		p.logger.Debug("found dnsmasq records", zap.Int("count", len(data.Rows)))
	}

	for _, row := range data.Rows {
		if row.Host == host && row.Domain == zone {
			if p.debug {
				p.logger.Debug("found matching dnsmasq record",
					zap.String("domain", domain),
					zap.String("uuid", row.UUID),
					zap.String("ip", row.IP))
			}
			return &DNSRecord{
				Domain:      domain,
				IP:          row.IP,
				RecordType:  "A", // dnsmasq doesn't specify record type explicitly
				UUID:        row.UUID,
				Enabled:     true, // dnsmasq hosts are always enabled
				Description: row.Description,
			}, nil
		}
	}

	if p.debug {
		p.logger.Debug("no matching dnsmasq record found", zap.String("domain", domain))
	}
	return nil, nil
}

func (p *OPNsenseProvider) reconfigure() error {
	var endpoint string
	if p.dnsService == "dnsmasq" {
		endpoint = "dnsmasq/service/reconfigure"
	} else {
		endpoint = "unbound/service/reconfigure"
	}

	if p.debug {
		p.logger.Debug("reconfiguring DNS service", zap.String("service", p.dnsService))
	}

	resp, err := p.apiCall(endpoint, nil)
	if err != nil {
		return err
	}
	var res struct {
		Status string `json:"status"`
	}
	if err := json.Unmarshal(resp, &res); err != nil {
		return err
	}
	if res.Status != "ok" {
		return fmt.Errorf("reconfigure failed: %s", string(resp))
	}

	if p.debug {
		p.logger.Debug("DNS service reconfigured successfully", zap.String("service", p.dnsService))
	}
	return nil
}

func (p *OPNsenseProvider) apiCall(endpoint string, payload any) ([]byte, error) {
	// endpoint already includes the full path like "dnsmasq/settings/add_host" or "unbound/settings/add_host_override"
	url := fmt.Sprintf("https://%s/api/%s", p.hostname, endpoint)

	if p.debug {
		p.logger.Debug("making API call",
			zap.String("url", url),
			zap.String("endpoint", endpoint),
			zap.Bool("has_payload", payload != nil))
	}

	var body io.Reader
	if payload != nil {
		data, _ := json.Marshal(payload)
		body = strings.NewReader(string(data))
		if p.debug {
			p.logger.Debug("API call payload", zap.String("payload", string(data)))
		}
	}
	req, err := http.NewRequest("POST", url, body)
	if err != nil {
		return nil, err
	}
	req.SetBasicAuth(p.apiKey, p.apiSecret)
	if payload != nil {
		req.Header.Set("Content-Type", "application/json")
	}
	resp, err := p.client.Do(req)
	if err != nil {
		if p.debug {
			p.logger.Debug("API call failed", zap.Error(err))
		}
		// Check for common SSL errors like in the shell script
		if strings.Contains(err.Error(), "certificate") || strings.Contains(err.Error(), "tls") {
			return nil, fmt.Errorf("SSL/TLS error connecting to OPNsense API. If using self-signed certificates, enable 'insecure' option: %w", err)
		}
		return nil, err
	}
	defer resp.Body.Close()
	out, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}

	if p.debug {
		p.logger.Debug("API call response",
			zap.Int("status_code", resp.StatusCode),
			zap.String("response", string(out)))
	}

	if resp.StatusCode >= 400 {
		return nil, fmt.Errorf("api error %d: %s", resp.StatusCode, string(out))
	}
	return out, nil
}

// Interface compliance
var _ DNSService = (*OPNsenseProvider)(nil)
