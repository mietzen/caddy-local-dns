package localdns_provider

import (
	"crypto/tls"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net"
	"net/http"
	"strings"
	"time"

	"go.uber.org/zap"
)

// DNSProvider interface for different DNS backends
type DNSProvider interface {
	CreateRecord(domain, ip string) error
	DeleteRecord(domain string) error
	UpdateRecord(domain, ip string) error
	FindRecord(domain string) (*DNSRecord, error)
}

// DNSRecord represents a DNS record
type DNSRecord struct {
	Domain      string
	IP          string
	RecordType  string
	UUID        string
	Enabled     bool
	Description string
}

// OPNsenseProvider implements DNSProvider for OPNsense
type OPNsenseProvider struct {
	hostname    string
	apiKey      string
	apiSecret   string
	dnsProvider string
	client      *http.Client
	logger      *zap.Logger
}

type opnsenseOverride struct {
	UUID        string `json:"uuid"`
	Enabled     string `json:"enabled"`
	Hostname    string `json:"hostname"`
	Domain      string `json:"domain"`
	RR          string `json:"rr"`
	MXPrio      string `json:"mxprio"`
	MX          string `json:"mx"`
	Server      string `json:"server"`
	Description string `json:"description"`
}

// dnsmasqHost represents a dnsmasq host entry
type dnsmasqHost struct {
	UUID        string `json:"uuid"`
	Host        string `json:"host"`
	Domain      string `json:"domain"`
	IP          string `json:"ip"`
	Description string `json:"descr"`
}

// NewOPNsenseProvider creates a new OPNsense provider
func NewOPNsenseProvider(hostname, apiKey, apiSecret, dnsProvider string, insecure bool, logger *zap.Logger) (*OPNsenseProvider, error) {
	if hostname == "" || apiKey == "" || apiSecret == "" {
		return nil, errors.New("opnsense provider requires hostname, api_key, and api_secret")
	}

	// Default to unbound if dns_provider not specified
	if dnsProvider == "" {
		dnsProvider = "unbound"
	}

	// Validate dns_provider
	if dnsProvider != "unbound" && dnsProvider != "dnsmasq" {
		return nil, fmt.Errorf("unsupported dns_provider: %s (must be 'unbound' or 'dnsmasq')", dnsProvider)
	}

	tr := &http.Transport{}
	if insecure {
		tr.TLSClientConfig = &tls.Config{
			InsecureSkipVerify: true,
		}
	}

	client := &http.Client{
		Timeout:   15 * time.Second,
		Transport: tr,
	}

	return &OPNsenseProvider{
		hostname:    hostname,
		apiKey:      apiKey,
		apiSecret:   apiSecret,
		dnsProvider: dnsProvider,
		client:      client,
		logger:      logger,
	}, nil
}

func (p *OPNsenseProvider) CreateRecord(domain, ip string) error {
	if !strings.Contains(domain, ".") {
		return fmt.Errorf("domain must contain a dot: %s", domain)
	}

	if p.dnsProvider == "dnsmasq" {
		return p.createDnsmasqRecord(domain, ip)
	}

	// Default to unbound
	return p.createUnboundRecord(domain, ip)
}

func (p *OPNsenseProvider) createUnboundRecord(domain, ip string) error {
	recordType := "A"
	if parsedIP := net.ParseIP(ip); parsedIP != nil && parsedIP.To4() == nil {
		recordType = "AAAA"
	}

	host := domain[:strings.IndexByte(domain, '.')]
	zone := domain[strings.IndexByte(domain, '.')+1:]

	payload := map[string]any{
		"host": map[string]any{
			"enabled":     "1",
			"hostname":    host,
			"domain":      zone,
			"rr":          recordType,
			"mxprio":      "",
			"mx":          "",
			"server":      ip,
			"description": "Generated by Caddy Local DNS",
		},
	}

	resp, err := p.apiCall("unbound/settings/add_host_override", payload)
	if err != nil {
		return err
	}

	var res struct {
		Result string `json:"result"`
	}
	if err := json.Unmarshal(resp, &res); err != nil {
		return err
	}
	if res.Result != "saved" {
		return fmt.Errorf("add_override failed: %s", string(resp))
	}

	// Reload config
	return p.reconfigure()
}

func (p *OPNsenseProvider) createDnsmasqRecord(domain, ip string) error {
	host := domain[:strings.IndexByte(domain, '.')]
	zone := domain[strings.IndexByte(domain, '.')+1:]

	payload := map[string]any{
		"host": map[string]any{
			"host":   host,
			"domain": zone,
			"ip":     ip,
			"descr":  "Generated by Caddy Local DNS",
		},
	}

	resp, err := p.apiCall("dnsmasq/settings/add_host", payload)
	if err != nil {
		return err
	}

	var res struct {
		Result string `json:"result"`
	}
	if err := json.Unmarshal(resp, &res); err != nil {
		return err
	}
	if res.Result != "saved" {
		return fmt.Errorf("add_host failed: %s", string(resp))
	}

	// Reload config
	return p.reconfigure()
}

func (p *OPNsenseProvider) UpdateRecord(domain, ip string) error {
	// Find existing record
	existing, err := p.FindRecord(domain)
	if err != nil {
		return err
	}
	if existing == nil {
		return p.CreateRecord(domain, ip)
	}

	// Delete old record
	if err := p.DeleteRecord(domain); err != nil {
		return err
	}

	// Create new record
	return p.CreateRecord(domain, ip)
}

func (p *OPNsenseProvider) DeleteRecord(domain string) error {
	existing, err := p.FindRecord(domain)
	if err != nil {
		return err
	}
	if existing == nil {
		return nil // Already deleted
	}

	var endpoint string
	if p.dnsProvider == "dnsmasq" {
		endpoint = "dnsmasq/settings/del_domain/" + existing.UUID
	} else {
		endpoint = "unbound/settings/del_host_override/" + existing.UUID
	}

	resp, err := p.apiCall(endpoint, nil)
	if err != nil {
		return err
	}

	var res struct {
		Result string `json:"result"`
	}
	if err := json.Unmarshal(resp, &res); err != nil {
		return err
	}
	if res.Result != "deleted" {
		return fmt.Errorf("delete_record failed: %s", string(resp))
	}

	return p.reconfigure()
}

func (p *OPNsenseProvider) FindRecord(domain string) (*DNSRecord, error) {
	if !strings.Contains(domain, ".") {
		return nil, fmt.Errorf("domain must contain a dot: %s", domain)
	}

	if p.dnsProvider == "dnsmasq" {
		return p.findDnsmasqRecord(domain)
	}

	// Default to unbound
	return p.findUnboundRecord(domain)
}

func (p *OPNsenseProvider) findUnboundRecord(domain string) (*DNSRecord, error) {
	host := domain[:strings.IndexByte(domain, '.')]
	zone := domain[strings.IndexByte(domain, '.')+1:]

	resp, err := p.apiCall("unbound/settings/search_host_override", nil)
	if err != nil {
		return nil, err
	}

	var data struct {
		Rows []opnsenseOverride `json:"rows"`
	}
	if err := json.Unmarshal(resp, &data); err != nil {
		return nil, err
	}

	for _, row := range data.Rows {
		if row.Hostname == host && row.Domain == zone {
			return &DNSRecord{
				Domain:      domain,
				IP:          row.Server,
				RecordType:  strings.SplitN(strings.TrimSpace(row.RR), " ", 2)[0],
				UUID:        row.UUID,
				Enabled:     row.Enabled == "1",
				Description: row.Description,
			}, nil
		}
	}

	return nil, nil
}

func (p *OPNsenseProvider) findDnsmasqRecord(domain string) (*DNSRecord, error) {
	host := domain[:strings.IndexByte(domain, '.')]
	zone := domain[strings.IndexByte(domain, '.')+1:]

	resp, err := p.apiCall("dnsmasq/settings/search_host", nil)
	if err != nil {
		return nil, err
	}

	var data struct {
		Rows []dnsmasqHost `json:"rows"`
	}
	if err := json.Unmarshal(resp, &data); err != nil {
		return nil, err
	}

	for _, row := range data.Rows {
		if row.Host == host && row.Domain == zone {
			return &DNSRecord{
				Domain:      domain,
				IP:          row.IP,
				RecordType:  "A", // dnsmasq doesn't specify record type explicitly
				UUID:        row.UUID,
				Enabled:     true, // dnsmasq hosts are always enabled
				Description: row.Description,
			}, nil
		}
	}

	return nil, nil
}

func (p *OPNsenseProvider) reconfigure() error {
	var endpoint string
	if p.dnsProvider == "dnsmasq" {
		endpoint = "dnsmasq/service/reconfigure"
	} else {
		endpoint = "unbound/service/reconfigure"
	}

	resp, err := p.apiCall(endpoint, nil)
	if err != nil {
		return err
	}
	var res struct {
		Status string `json:"status"`
	}
	if err := json.Unmarshal(resp, &res); err != nil {
		return err
	}
	if res.Status != "ok" {
		return fmt.Errorf("reconfigure failed: %s", string(resp))
	}
	return nil
}

func (p *OPNsenseProvider) apiCall(endpoint string, payload any) ([]byte, error) {
	// endpoint already includes the full path like "dnsmasq/settings/add_host" or "unbound/settings/add_host_override"
	url := fmt.Sprintf("https://%s/api/%s", p.hostname, endpoint)
	var body io.Reader
	if payload != nil {
		data, _ := json.Marshal(payload)
		body = strings.NewReader(string(data))
	}
	req, err := http.NewRequest("POST", url, body)
	if err != nil {
		return nil, err
	}
	req.SetBasicAuth(p.apiKey, p.apiSecret)
	if payload != nil {
		req.Header.Set("Content-Type", "application/json")
	}
	resp, err := p.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	out, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	if resp.StatusCode >= 400 {
		return nil, fmt.Errorf("api error %d: %s", resp.StatusCode, string(out))
	}
	return out, nil
}

// Interface compliance
var _ DNSProvider = (*OPNsenseProvider)(nil)
